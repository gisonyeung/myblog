import React from 'react';
import { Link } from 'react-router';
import ArticleContent from './ArticleContent';
import ArticleHot from './ArticleHot';
import ArticleComment from './ArticleComment';
import BlogAction from '../actions/BlogAction';
import BlogStore from '../stores/BlogStore';
import hljs from 'highlight.js';
// import 'highlight.js/styles/tomorrow-night-bright.css';
import '../sass/highlight.scss';
window.hljs = hljs;


const ArticlePanel = React.createClass({

  getInitialState() {
    // 换成异步的时候，移至getInitial
    // BlogAction.fetchBlogDetail(this.props.blogId);
    return {
        // blog: {
        //   time: {},
        //   numbers: {
        //   	like: 0,
        //   	view: 0,
        //   }
        // },
      "blog": {
        "_id": "58b2f0e4ee1d31344d29c664",
          "blogId": 11,
            "title": "ES6 特性总结",
              "summary": "内推即将开始，最近开始投入进行面试知识的总结。\n这篇博文总结了 ES6 的一些新特性，并包含其中的一些使用技巧和注意事项。",
                "content": "<p>ES6 包装了许多语法糖，使用 ES6 编写的代码相比 ES5 来说要更加的简洁清晰。</p>\n\n<p>得益于 babel ，我们在日常开发时可以比较自由的使用 ES6、ES7。</p>\n\n<p>下面开始总结介绍 ES6 特性。</p>\n\n<h1 id=\"1letconst\">1. let 与 const</h1>\n\n<p>除了 <code>var</code> ，我们现在还可以使用两个新的标示符来定义一个变量 —— <code>let</code> 和 <code>const</code>。和 <code>var</code> 不一样的是，<code>let</code> 和 <code>const</code> 不存在变量提升。</p>\n\n<p>使用<code>var</code>，<code>#1</code>处会产生变量提升，使用 ES5 时我们可能会无意屏蔽到外层作用域变量：</p>\n\n<pre><code>var snack = 'Meow Mix';\n\nfunction getFood(food) {\n    if (food) {\n        var snack = 'Friskies'; // #1\n        return snack;\n    }\n    return snack;\n}\n\ngetFood(false); // undefined\n</code></pre>\n\n<p>而通过使用<code>let</code>，我们可以避免出现这种现象：</p>\n\n<pre><code>let snack = 'Meow Mix';\n\nfunction getFood(food) {\n    if (food) {\n        let snack = 'Friskies';\n        return snack;\n    }\n    return snack;\n}\n\ngetFood(false); // 'Meow Mix'\n</code></pre>\n\n<p>原因是因为，<code>let</code>和<code>const</code>会产生一个块级作用域，因此在变量未被定义之前使用它会产生一个 <code>ReferenceError</code>。</p>\n\n<pre><code>console.log(x); // ReferenceError: x is not defined\nlet x = 'hi';\n</code></pre>\n\n<p>要注意的是，这里还有一个概念<strong>“暂时性死区”</strong>：在代码块内使用<code>let</code>命令声明变量之前，该变量都是不可用的，不受外部变量影响。</p>\n\n<pre><code>let x = 'hi';\n\nfunction sayHi() {\n    console.log(x);\n    let x = 'hii';\n    console.log(x);\n}\n\nsayHi(); // Uncaught ReferenceError: x is not defined (Line 4);\n</code></pre>\n\n<p>所以，虽然<code>let</code>不会发生变量提升，但是会出现暂时性死区，这个是需要注意的。</p>\n\n<p>另外，<code>let</code>和<code>const</code>在同一作用域层级中是不允许重复声明的。</p>\n\n<p>对于<code>let</code>和<code>const</code>特性的总结如下：</p>\n\n<ol>\n<li>块局作用域；</li>\n\n<li>不存在变量提升，一定声明后才能使用；</li>\n\n<li>暂时性死区，在代码块内使用<code>let</code>命令声明变量之前，该变量都是不可用的，不受外部变量影响；</li>\n\n<li>在相同作用域范围内不允许重复声明；</li>\n\n<li><code>const</code>与<code>let</code>不同点在于：\n\n\n<ul>\n<li><code>const</code>如果声明的变量是简单的值，则不能改变变量的值，修改会报错；</li>\n\n<li><code>const</code>如果声明的是复合类型的变量，则只保证变量地址不变，值可以变；</li></ul>\n</li>\n</ol>\n\n<h1 id=\"2\">2. 块级作用域 { }</h1>\n\n<p>在 ES6 以前，我们经常需要使用<strong>函数立即执行表达式</strong>（IIFE）来创造一个内部作用域。</p>\n\n<p>例如：</p>\n\n<pre><code>(function () {\n    var food = 'Meow Mix';\n}());\n\nconsole.log(food); // Reference Error\n</code></pre>\n\n<p>而在 ES6 中，我们已经可以直接使用块级作用域了。</p>\n\n<pre><code>{\n    let food = 'Meow Mix';\n    console.log('[Block Scope] ', food); // '[Block Scope] Meow Mix'\n}\n\nconsole.log(food); // Reference Error\n</code></pre>\n\n<h1 id=\"3\">3. 箭头函数</h1>\n\n<p>我们经常需要给回调函数维护一个词法作用域的上下文 <code>this</code>。</p>\n\n<pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.prefixName = function (arr) {\n    return arr.map(function (character) {\n        return this.name + character; // Cannot read property 'name' of undefined\n    });\n};\n</code></pre>\n\n<p>常用的解决办法是通过闭包变量寄存<code>this</code>：</p>\n\n<pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.prefixName = function (arr) {\n    var that = this; // Store the context of this\n    return arr.map(function (character) {\n        return that.name + character;\n    });\n};\n</code></pre>\n\n<p>或者， 通过传递<code>this</code>：</p>\n\n<pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.prefixName = function (arr) {\n    return arr.map(function (character) {\n        return this.name + character;\n    }, this);\n}\n</code></pre>\n\n<p>还可以通过上下文绑定的方式维护<code>this</code>：</p>\n\n<pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.prefixName = function (arr) {\n    return arr.map(function (character) {\n        return this.name + character;\n    }.bind(this));\n};\n</code></pre>\n\n<p>而<strong>箭头函数</strong>的出现，其中一个好处就是可以消除这小部分维护<code>this</code>的冗余：</p>\n\n<pre><code>function Person(name) {\n    this.name = name;\n}\n\nPerson.prototype.prefixName = function (arr) {\n    return arr.map(character =&gt; this.name + character);\n};\n</code></pre>\n\n<p>使用<strong>箭头函数</strong>时，<code>this</code>会自动绑定到当前作用域的<code>this</code>。</p>\n\n<p><strong>箭头函数</strong>还有另一个好处，<strong>可以更加简洁并很简单地返回一个值</strong>。</p>\n\n<p>函数式编程注重数据到数据之间的映射，而箭头函数的出现某种程度上就是函数式的一种体现。</p>\n\n<pre><code>const arr = [1, 2, 3, 4, 5];\nconst squares = arr.map(x =&gt; x * x);\nconsole.log(squares); // [1, 4, 9, 16, 25];\n</code></pre>\n\n<h1 id=\"4\">4. 一些字符串工具函数</h1>\n\n<p>在 ES6 中，标准库升级了很多，在这些变化中有许多新的对于字符串的函数，比如 <code>.includes()</code> 和 <code>.repeat()</code>。</p>\n\n<h2 id=\"41includes\">4.1 .includes()</h2>\n\n<p>在 ES5 中我们使用 <code>indexOf()</code> 函数的返回值是否 <code>&gt;-1</code> 来判断字符串是否包含某些字符串：</p>\n\n<pre><code>var string = 'food';\nvar substring = 'foo';\nconsole.log(~string.indexOf(substring));\n</code></pre>\n\n<p>而现在现在我们更简单地使用 <code>.includes()</code> 来返回一个布尔值来判断：</p>\n\n<pre><code> const string = 'food';\nconst substring = 'foo';\n\nconsole.log(string.includes(substring)); // true\n</code></pre>\n\n<h2 id=\"42repeat\">4.2 .repeat()</h2>\n\n<p>在 ES5 中，我们需要实现将一个字符串重复 n 次进行拼接：</p>\n\n<pre><code>function repeat(string, count) {\n    var strings = [];\n    while(strings.length &lt; count) {\n        strings.push(string);\n    }\n    return strings.join('');\n}\n</code></pre>\n\n<p>在 ES6 中，可以更简便地实现：</p>\n\n<pre><code>'meow'.repeat(3); // 'meowmeowmeow'\n</code></pre>\n\n<h2 id=\"43\">4.3 模板字符串 ` `</h2>\n\n<p>模板字符串的出现，提供了很多便利。</p>\n\n<h3 id=\"431\">4.3.1 免转义</h3>\n\n<p>使用<strong>模版字符串</strong>我们可以不用对某些特殊字符进行转义处理。</p>\n\n<p>ES5：</p>\n\n<pre><code>var text = \"This string contains \\\"double quotes\\\" which are escaped.\";\n</code></pre>\n\n<p>ES6：</p>\n\n<pre><code>let text = `This string contains \"double quotes\" which don't need to be escaped anymore.`;\n</code></pre>\n\n<h3 id=\"432\">4.3.2 字符串插值</h3>\n\n<p><strong>模版字符串</strong>还支持字符串插值，可以把变量值（或表达式）和字符串连接起来。</p>\n\n<p>ES5：</p>\n\n<pre><code>var name = 'Tiger';\nvar age = 13;\n\nconsole.log('My cat is named ' + name + ' and is ' + age + ' years old.');\n</code></pre>\n\n<p>ES6：</p>\n\n<pre><code>const name = 'Tiger';\nconst age = 13;\n\nconsole.log(`My cat is named ${name} and is ${age} years old.`);\n</code></pre>\n\n<h3 id=\"433\">4.3.3 换行</h3>\n\n<p>在 ES5 中，需要换行时，需要这样：</p>\n\n<pre><code>var text = (\n    'cat\\n' +\n    'dog\\n' +\n    'nickelodeon'\n);\n</code></pre>\n\n<p>或者这样：</p>\n\n<pre><code>var text = [\n    'cat',\n    'dog',\n    'nickelodeon'\n].join('\\n');\n</code></pre>\n\n<p><strong>模板字符串</strong>可以支持换行并且不需要进行额外的处理：</p>\n\n<pre><code>let text = ( `cat\ndog\nnickelodeon`\n);\n</code></pre>\n\n<p>不过使用模板字符串时需要注意，需要<strong>使用括号将表达式括起来</strong>或者<strong>在末尾加上分号</strong>。例如：</p>\n\n<pre><code>// bad\nlet text = `cat`\n\n// good\nlet text1 = `cat`;\nlet text2 = (`cat`)\nlet text3 = (`cat`);\n</code></pre>\n\n<p>为什么需要这样呢？</p>\n\n<p>因为我们平常写 ES6 时都是需要经过 babel 转码的，而如果模板字符串末尾省略分号，而下一行紧接着是一个 IIFE 的话，那么这个字符串如<code>cat</code>会被当成一个函数调用。例如：</p>\n\n<pre><code>let text1 = `cat`\n(function() { // todo })();\n</code></pre>\n\n<p>转码后：</p>\n\n<pre><code>var text1 = cat(function() { ... })(); // cat is not a function\n</code></pre>\n\n<p>某天刷知乎偶然看到这个坑，有关这个坑的具体介绍可阅读这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/24612490\">不写分号的前端攻城师们注意了！需要加分号的情况又多了一种</a>。</p>\n\n<h1 id=\"5\">5. 解构赋值</h1>\n\n<p>解构赋值可以让我们用一个更简便的语法从一个数组或者对象（即使是深层的）中分离出来值，并存储他们。</p>\n\n<h2 id=\"51\">5.1 解构数组</h2>\n\n<pre><code>let [a, b, c, d] = [1, 2, 3, 4];\n\nconsole.log(a); // 1\nconsole.log(b); // 2\n</code></pre>\n\n<h2 id=\"52\">5.2 解构对象</h2>\n\n<pre><code>const luke = { occupation: 'jedi', father: 'anakin' };\nconst  {occupation, father } = luke;\n\nconsole.log(occupation); // 'jedi'\nconsole.log(father); // 'anakin'\n</code></pre>\n\n<h1 id=\"6\">6. 模块</h1>\n\n<p>在 ES6 之前，我们需要使用类似 <code>Browserify</code>的库来创建客户端的模块化，在 <code>node.js</code> 中需要使用 <code>require</code>。</p>\n\n<p>而在 ES6 中，我们可以同时使用 AMD 和 CommonJS 类型的模块化。</p>\n\n<h2 id=\"61\">6.1 导出</h2>\n\n<h3 id=\"611commonjs\">6.1.1 使用 CommonJS 出口</h3>\n\n<pre><code>module.exports = 1;\nmodule.exports = { foo: 'bar' };\nmodule.exports = ['foo', 'bar'];\nmodule.exports = function bar () {};\n</code></pre>\n\n<h3 id=\"612es6\">6.1.2 使用 ES6 的出口</h3>\n\n<p>在 ES6 中我们可以暴露多个值。</p>\n\n<pre><code>export let name = 'Gison';\nexport let age  =21;​​\n</code></pre>\n\n<p>或者暴露一个对象列表：</p>\n\n<pre><code>function sumTwo(a, b) {\n    return a + b;\n}\n\nfunction sumThree(a, b, c) {\n    return a + b + c;\n}\n\nexport { sumTwo, sumThree };\n</code></pre>\n\n<p>我们还可以暴露函数、对象和其他的值，通过简单地使用 <code>export</code> 这个关键字：</p>\n\n<pre><code>export function sumTwo(a, b) {\n    return a + b;\n}\n\nexport function sumThree(a, b, c) {\n    return a + b + c;\n}\n</code></pre>\n\n<p>最后，我们还可以绑定一个默认的输出：</p>\n\n<pre><code>function sumTwo(a, b) {\n    return a + b;\n}\n\nfunction sumThree(a, b, c) {\n    return a + b + c;\n}\n\nlet api = {\n    sumTwo,\n    sumThree\n};\n\nexport default api;\n\n/* Which is the same as\n * export { api as default };\n */\n</code></pre>\n\n<h2 id=\"62\">6.2 导入</h2>\n\n<p>在 ES6 中同样提供了多样的导入方式。</p>\n\n<h3 id=\"621\">6.2.1 整体导入</h3>\n\n<pre><code>import 'underscore';\n</code></pre>\n\n<h3 id=\"622\">6.2.2 解构导入</h3>\n\n<pre><code>import { sumTwo, sumThree } from 'math/addition';\n</code></pre>\n\n<h3 id=\"623\">6.2.3 重命名导入</h3>\n\n<pre><code>import {\n    sumTwo as addTwoNumbers,\n    sumThree as sumThreeNumbers\n} from 'math/addition';\nimport * as util from 'math/addition';\n</code></pre>\n\n<h3 id=\"624\">6.2.4 混合导入</h3>\n\n<pre><code>export { foo as default, foo1, foo2 }\nimport foo, { foo1, foo2 } from 'foos';\n\nimport React, { Component, PropTypes } from 'react'; \n</code></pre>\n\n<h1 id=\"7\">7. 参数</h1>\n\n<p>在 ES5 中，在函数中我们需要各种操作去处理<strong>默认参数</strong>、<strong>不定参数</strong>和<strong>重命名参数</strong>等需求，在 ES6 中我们可以直接使用更简洁的语法完成这些需求。</p>\n\n<h2 id=\"71\">7.1 默认参数</h2>\n\n<p>ES5：</p>\n\n<pre><code>function addTwoNumbers(x, y) {\n    x = x || 0;\n    y = y || 0;\n    return x + y;\n}\n</code></pre>\n\n<p>ES6 中，函数的参数可以支持设置默认值：：</p>\n\n<pre><code>function addTwoNumbers(x=0, y=0) {\n    return x + y;\n}\n</code></pre>\n\n<pre><code>addTwoNumbers(2, 4); // 6\naddTwoNumbers(2); // 2\naddTwoNumbers(); // 0\n</code></pre>\n\n<h2 id=\"72rest\">7.2 rest 参数</h2>\n\n<p>在 ES5 中，我们需要这么处理不定参数：</p>\n\n<pre><code>function logArguments() {\n    for (var i=0; i &lt; arguments.length; i++) {\n        console.log(arguments[i]);\n    }\n}\n</code></pre>\n\n<p>在 ES6 中，使用 rest ，我们可以这样处理不确定数量的参数：</p>\n\n<pre><code>function logArguments(...args) {\n    for (let arg of args) {\n        console.log(arg);\n    }\n}\n</code></pre>\n\n<p>也可以使用 rest 表达式进行展开操作。\n在 ES5 中，我们可以 <code>apply</code> <code>Math.max</code> 方法来获得一个数组中的最大值：</p>\n\n<pre><code>Math.max.apply(null, [-1, 100, 9001, -32]); // 9001\n</code></pre>\n\n<p>在 ES6 中，我们可以直接通过展开操作把一个数组的值作为参数传递给一个函数：</p>\n\n<pre><code>Math.max(...[-1, 100, 9001, -32]); // 9001\n</code></pre>\n\n<p>我们可以更简洁地使用这个语法来合并数组：</p>\n\n<pre><code>let cities = ['San Francisco', 'Los Angeles'];\nlet places = ['Miami', ...cities, 'Chicago']; // ['Miami', 'San Francisco', 'Los Angeles', 'Chicago']\n</code></pre>\n\n<h2 id=\"73\">7.3 命名参数</h2>\n\n<p>在 ES5 中使用配置对象的模式来进行命名参数或参数纠正，例如：</p>\n\n<pre><code>function initializeCanvas(options) {\n    var height = options.height || 600;\n    var width  = options.width  || 400;\n    var lineStroke = options.lineStroke || 'black';\n}\n</code></pre>\n\n<p>在 ES6 中，我们可以直接利用解构一个函数的形参实现相同的功能：</p>\n\n<pre><code>function initializeCanvas({ height=600, width=400, lineStroke='black' }) {\n    // Use variables height, width, lineStroke here\n }\n</code></pre>\n\n<p>如果我们想使整个值可选择，我们可以结合默认参数：</p>\n\n<pre><code>function initializeCanvas({ height=600, width=400, lineStroke='black' } = {}) {\n    // ...\n}\n</code></pre>\n\n<h1 id=\"8class\">8. 类 Class</h1>\n\n<p>在 ES6 之前，我们通过构造函数来创造一个类，并且通过原型来扩展属性：</p>\n\n<pre><code>function Person(name, age, gender) {\n    this.name   = name;\n    this.age    = age;\n    this.gender = gender;\n}\n\nPerson.prototype.incrementAge = function () {\n    return this.age += 1;\n};\n</code></pre>\n\n<p>然后可以这样继承类：</p>\n\n<pre><code>function Personal(name, age, gender, occupation, hobby) {\n    Person.call(this, name, age, gender);\n    this.occupation = occupation;\n    this.hobby = hobby;\n}\n\nPersonal.prototype = Object.create(Person.prototype);\nPersonal.prototype.constructor = Personal;\nPersonal.prototype.incrementAge = function () {\n    Person.prototype.incrementAge.call(this);\n    this.age += 20;\n    console.log(this.age);\n};\n\nvar Gison = new Personal('Gison', 21, '本科', 'FE', 'coding');\n</code></pre>\n\n<p>在 ES6 中，提供了更多的语法糖，可以直接创造一个类：</p>\n\n<pre><code>class Person {\n    constructor(name, age, gender) {\n        this.name   = name;\n        this.age    = age;\n        this.gender = gender;\n    }\n\n    incrementAge() {\n      this.age += 1;\n    }\n}\n</code></pre>\n\n<p>使用 <code>extends</code> 关键字来继承一个类：</p>\n\n<pre><code>class Personal extends Person {\n    constructor(name, age, gender, occupation, hobby) {\n        super(name, age, gender);\n        this.occupation = occupation;\n        this.hobby = hobby;\n    }\n\n    incrementAge() {\n        super.incrementAge();\n        this.age += 20;\n        console.log(this.age);\n    }\n}\n</code></pre>\n\n<p>当然，ES6 中虽然实现了“类”，但 JavaScript 中实际上是没有像 Java 那样的类存在的。JavaScript 中的类的实现同样是基于原型链的。</p>\n\n<h1 id=\"9symbol\">9. Symbol</h1>\n\n<p>在 ES6 之前 只有 6 种基本数据类型，包括 5 种基本数据类型（<strong>Undefined</strong>、<strong>Nulll</strong>、<strong>Boolean</strong>、<strong>Number</strong>、<strong>String</strong>）和 1 种引用数据类型（<strong>Object</strong>）。在 ES6 中又新增了一种基本数据类型，**Symbol``，它表示独一无二的值。</p>\n\n<h2 id=\"91symbol\">9.1 生成 Symbol</h2>\n\n<p><strong>方法 1</strong>：</p>\n\n<pre><code>let s = Symbol();\nconsole.log(s); // Symbol()\ntypeof s; // \"symbol\"\n</code></pre>\n\n<p><strong>方法 2</strong>：我们还可以给Symbol函数传递一个参数，用于对这个 Symbol 值进行描述，方便我们区分不同的 Symbol 值，以及调试。</p>\n\n<pre><code>let s1 = Symbol('s1');\nlet s2 = Symbol('s2');\n\ntypeof s1; // \"symbol\"\ntypeof s2; // \"symbol\"\n\nconsole.log(s1); // Symbol(s1)\nconsole.log(s2); // Symbol(s2)\n\ns1 === s2; // false\ns1.toString(); // \"Symbol(s1)\"\ns2.toString(); // \"Symbol(s2)\"\n\nlet s3 = Symbol('s2');\ns3 === s2; // false\n</code></pre>\n\n<p>从上面的代码中，我们可以看出来：</p>\n\n<ol>\n<li>我们可以通过给 Symbol 函数传递一个参数，用来区别不同的Symbol值。</li>\n\n<li>给 Symbol 函数传递了描述参数的 Symbo l值不论是通过控制台打印，还是调用它自身的 toString 方法都会显示出来它的描述词，便于区分。</li>\n\n<li>就算给 Symbol 函数传递相同的描述字符串，它生成的 Symbol 值也是不一样的。只是它们的描述符是一样的。</li>\n</ol>\n\n<p><strong>方法 3</strong>：我们还可以使用另一个生成 Symbol 值的函数<code>Symbol.for()</code>来生成 Symbol 类型的值。</p>\n\n<pre><code>// 方法三\nlet s4 = Symbol.for('s4');\nconsole.log(s4); // Symbol(s4)\ns4.toString(); // \"Symbol(s4)\"\n\nlet s5 = Symbol.for('s4');\ns5 === s4; // true\n\nSymbol.keyFor(s3); // undefined\nSymbol.keyFor(s4); // \"s4\"\n</code></pre>\n\n<p>使用<code>Symbol.for(describe)</code>方法会先在全局环境中查找有没有使用 describe 注册的 Symbol 值，如果有的话就会返回找到的那个值，如果没有的话就会重新创建一个。这样做的目的使我们可以重复使用之前定义过的 Symbol 值，或者修改与之相关的一些东西。</p>\n\n<p>说到这里，我们就要提及另一个与<code>Symbol.for()</code>相关的函数<code>Symbol.keyFor()</code>，这个函数是用来查找一个 Symbol 值的注册信息的，如果你是使用<code>Symbol()</code>函数创建的 Symbol 值，不论你传不传递参数，那么通过<code>Symbol.keyFor()</code>函数是查找不到它的注册信息的。</p>\n\n<h2 id=\"92symbol\">9.2 使用 Symbol</h2>\n\n<p>那么 Symbol 有什么使用场景呢？</p>\n\n<h3 id=\"921\">9.2.1 作为对象的属性名，避免覆盖重写</h3>\n\n<p>在实际的工作中，我们可能会经常使用到别人写的类库，然后因为不知道某个对象的属性名，就可能不小心重写了那个对象的某个属性，导致一些不必要的错误出现。但是有了 Symbol 类型后，我们可以很容易的避免掉这样的失误。</p>\n\n<pre><code>// 使用字符串或者 Symbol 值来作为对象的属性了\nlet a = {};\nlet b = {};\nlet c = {};\nlet s4 = Symbol('s4');\n\n// 第 1 种方法使用 Symbol 作为属性名\na[s4] = 1;\n// 第 2 种方法使用 Symbol 作为属性名\nb = { [s4]: function(){}}\n// 第 3 种方法使用 Symbol 作为属性名\nObject.defineProperty(c, s4, {value: 'hello'});\n\na[s4]; // 1\nb[s4]; // function(){}\nc[s4]; // \"hello\"\n\na.s4; // undefined\n</code></pre>\n\n<p>使用 Symbo l值作为对象的属性名称可以有效地避免属性名的覆盖或者改写，当然你也要付出一点小代价：<strong>使用对象的 Symbol 值作为属性名字的时候，获取相应的属性值需要使用<code>obj[symbol]</code>的方式来获取相应的属性值。不可以使用<code>.</code>运算符来获取相应的属性值</strong>。</p>\n\n<h3 id=\"922\">9.2.2 作为一些常量来使用，可以有效地避免覆盖</h3>\n\n<pre><code>// 比如一个log()函数，可能有不同级别的输出信息，我们可以定义一组常量来表示\nconst LOG_LEVEL = {\n    NORMAL: Symbol('normal'),\n    WARN: Symbol('warn'),\n    ERROR: Symbol('error')\n}\n// log不同级别的信息\nlog(LOG_LEVEL.NORMAL, '...');\nlog(LOG_LEVEL.ERROR, '...');\n</code></pre>\n\n<h2 id=\"93symbol\">9.3 获取对象上的 Symbol() 值</h2>\n\n<p>使用 Symbol 值作为对象的属性名，也需要我们注意一点，那就是我们不能够通过使用<code>Object.keys()</code>，<code>Object.getOwnPropertyNames()</code>来获取这些属性名了，当然这些属性名也不会出现在<code>for ...in</code>或者<code>for...of</code>循环中：</p>\n\n<pre><code>// a就是上面的那个对象a，我们给它新增加一个字符串属性\na.name = 'hello';\n\nObject.keys(a); // [\"name\"]\nObject.getOwnPropertyNames(a); // [\"name\"]\nfor(var i in a) {console.log(i)} // name\nfor(var i of a) {console.log(i)} // name\n</code></pre>\n\n<p>我们可以使用<code>Object.getOwnPropertySymbols()</code>方法获取一个对象上的 Symbol 值的属性名。也可以使用一个新的 API <code>Reflect.ownKeys()</code>函数返回一个对象的所有键名，包括常规的字符串键名以及 Symbol 键名。</p>\n\n<pre><code>Object.getOwnPropertySymbols(a); // [Symbol(s4)]\n// 返回所有键名\nReflect.ownKeys(a); // [\"name\", Symbol(s4)]\n</code></pre>\n\n<h1 id=\"10map\">10. Map</h1>\n\n<p>Map 在 JavaScript 中是一个非常必须的数据结构，在 ES6 之前，我们通过对象来实现哈希表：</p>\n\n<pre><code>var map = new Object();\nmap[key1] = 'value1';\nmap[key2] = 'value2';\n</code></pre>\n\n<p>而 ES6 中的 Map 允许我们对值进行 <code>set</code>、<code>get</code> 和 <code>search</code> 的操作：</p>\n\n<pre><code>let map = new Map();\nmap.set('name', 'Gison');\nmap.get('name'); // Gison\nmap.has('name'); // true\n</code></pre>\n\n<p>Map 令人惊奇的部分就是它不仅限于使用字符串作为 key，还可以用其他任何类型的数据作为 key：</p>\n\n<pre><code>let map = new Map([\n    ['name', 'Gison'],\n    [true, 'false'],\n    [1, 'one'],\n    [{}, 'object'],\n    [function () {}, 'function']\n]);\n\nfor (let key of map.keys()) {\n    console.log(typeof key); // string, boolean, number, object, function\n}\n</code></pre>\n\n<p>基于这个特性，在我们实现<strong>数组去重</strong>时，就可以考虑采用 ES6 的 Map 来解决了。</p>\n\n<p>除了<code>.keys()</code>外，我们还可以使用 <code>.entries()</code> 来遍历迭代：</p>\n\n<pre><code>for (let [key, value] of map.entries()) {\n    console.log(key, value);\n}\n</code></pre>\n\n<h1 id=\"weakmap\">WeakMap</h1>\n\n<p>在 ES6 之前，为了存储私有变量，我们有各种各样的方法去实现，其中一种方法就是用命名约定：</p>\n\n<pre><code>class Person {\n    constructor(age) {\n        this._age = age;\n    }\n\n    _incrementAge() {\n        this._age += 1;\n    }\n}\n</code></pre>\n\n<p>但是命名约定在代码中仍然会令人混淆并且并不会<strong>真正的保持私有变量不被访问</strong>。现在，我们可以使用 <strong>WeakMap</strong> 来存储变量：</p>\n\n<pre><code>let _age = new WeakMap();\nclass Person {\n    constructor(age) {\n        _age.set(this, age);\n    }\n\n    incrementAge() {\n        let age = _age.get(this) + 1;\n        _age.set(this, age);\n        if (age &gt; 50) {\n            console.log('Midlife crisis');\n        }\n    }\n}\n</code></pre>\n\n<p>在 WeakMap 存储变量时，它的 key 不会产生属性名称，可以使用 <code>Reflect.ownKeys()</code> 来查看这一点：</p>\n\n<pre><code>const person = new Person(50);\nperson.incrementAge(); // 'Midlife crisis'\nReflect.ownKeys(person); // []\n</code></pre>\n\n<p>实际的实践就是可以用 WeakMap 来储存 DOM 元素，<strong>WeakMap 存储变量采用的是弱引用机制，在存储时不会增加变量的引用次数</strong>，因而不会污染元素本身：</p>\n\n<pre><code>let map = new WeakMap();\nlet el  = document.getElementById('someElement');\n\n// Store a weak reference to the element with a key\nmap.set(el, 'reference');\n\n// Access the value of the element\nlet value = map.get(el); // 'reference'\n\n// Remove the reference\nel.parentNode.removeChild(el);\nel = null;\n\n// map is empty, since the element is destroyed\n</code></pre>\n\n<p>当一个对象被垃圾回收机制销毁的时候， WeakMap 将会自动地移除关于这个对象地键值对。</p>\n\n<h1 id=\"12promise\">12. Promise</h1>\n\n<p>Promise 可以让我们远离平行的代码（回调地狱）：</p>\n\n<pre><code>func1(function (value1) {\n    func2(value1, function (value2) {\n        func3(value2, function (value3) {\n            func4(value3, function (value4) {\n                func5(value4, function (value5) {\n                    // Do something with value 5\n                });\n            });\n        });\n    });\n});\n</code></pre>\n\n<p>转变成垂直代码：</p>\n\n<pre><code>func1(value1)\n    .then(func2)\n    .then(func3)\n    .then(func4)\n    .then(func5, value5 =&gt; {\n        // Do something with value 5\n    });\n</code></pre>\n\n<p><strong>Promise 的好处：对错误的处理使用一些列回调会使代码很混乱，使用 Promise ，我们可以清晰地让错误冒泡并且在合适的时候处理它，而且，在 Promise 确定了 resolved/rejected 之后，他的值是不可再次改变的。</strong></p>\n\n<p>实际例子：</p>\n\n<pre><code>var request = require('request');\n\nreturn new Promise((resolve, reject) =&gt; {\n  request.get(url, (error, response, body) =&gt; {\n    if (body) {\n        resolve(JSON.parse(body));\n      } else {\n        resolve({});\n      }\n  });\n});\n</code></pre>\n\n<p>我们还可以使用 <code>Promise.all()</code> 来并行处理多个异步函数：</p>\n\n<pre><code>let urls = [\n  '/api/commits',\n  '/api/issues/opened',\n  '/api/issues/assigned',\n  '/api/issues/completed',\n  '/api/issues/comments',\n  '/api/pullrequests'\n];\n\nlet promises = urls.map((url) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    $.ajax({ url: url })\n      .done((data) =&gt; {\n        resolve(data);\n      });\n  });\n});\n\nPromise.all(promises)\n  .then((results) =&gt; {\n    // Do something with results of all our promises\n });\n</code></pre>\n\n<h1 id=\"13generator\">13. Generator 生成器</h1>\n\n<p>就像 Promise 可以帮我们避免回调地狱，Generator 可以帮助我们让代码风格更整洁——用同步的代码风格来写异步代码，它本质上是一个可以暂停计算并且可以随后返回表达式的值的函数。</p>\n\n<p>一个简单的例子使用 generator：</p>\n\n<pre><code>function* sillyGenerator() {\n    yield 1;\n    yield 2;\n    yield 3;\n    yield 4;\n}\n\nvar generator = sillyGenerator();\nconsole.log(generator.next()); // { value: 1, done: false }\nconsole.log(generator.next()); // { value: 2, done: false }\nconsole.log(generator.next()); // { value: 3, done: false }\nconsole.log(generator.next()); // { value: 4, done: false }\n</code></pre>\n\n<p><code>next</code> 可以回去到下一个 <code>yield</code> 返回的值，当然上面的代码是非常不自然的，我们可以利用 Generator 来用同步的方式来写异步操作：</p>\n\n<pre><code>// Hiding asynchronousity with Generators\n\nfunction request(url) {\n    getJSON(url, function(response) {\n        generator.next(response);\n    });\n}\n</code></pre>\n\n<p>这里的 generator 函数将会返回需要的数据：</p>\n\n<pre><code>function* getData() {\n    var entry1 = yield request('http://some_api/item1');\n    var data1  = JSON.parse(entry1);\n    var entry2 = yield request('http://some_api/item2');\n    var data2  = JSON.parse(entry2);\n}\n</code></pre>\n\n<p>通过 <code>yield</code>，我们可以保证 <code>data1</code> 有 <code>data2</code> 中我们需要解析并储存的数据。</p>\n\n<p>虽然我们可以利用 Generator 来用同步的方式来写异步操作，但是确认错误的传播变得不再清晰，我们可以在 Generator 中加上 Promise：</p>\n\n<pre><code>function request(url) {\n    return new Promise((resolve, reject) =&gt; {\n        getJSON(url, resolve);\n    });\n}\n</code></pre>\n\n<p>然后我们写一个函数逐步调用 <code>next</code> 并且利用 request 方法产生一个 Promise：</p>\n\n<pre><code>function iterateGenerator(gen) {\n    var generator = gen();\n    (function iterate(val) {\n        var ret = generator.next();\n        if(!ret.done) {\n            ret.value.then(iterate);\n        }\n    })();\n}\n</code></pre>\n\n<p>在 Generator 中加上 Promise 之后我们可以更清晰的使用 Promise 中的 <code>.catch</code> 和 <code>reject</code>来捕捉错误，让我们使用新的 Generator，和之前的还是蛮相似的：</p>\n\n<pre><code>iterateGenerator(function* getData() {\n    var entry1 = yield request('http://some_api/item1');\n    var data1  = JSON.parse(entry1);\n    var entry2 = yield request('http://some_api/item2');\n    var data2  = JSON.parse(entry2);\n});\n</code></pre>\n\n<h1 id=\"14asyncawait\">14. Async Await</h1>\n\n<p>这是 ES7 中的新特性，但是目前 babel 转码已经支持。</p>\n\n<p><code>async await</code> 让我们可以使用更精简明了的代码处理实现 Promise 和 Generator 所实现的异步处理：</p>\n\n<pre><code>var request = require('request');\n\nfunction getJSON(url) {\n  return new Promise(function(resolve, reject) {\n    request(url, function(error, response, body) {\n      resolve(body);\n    });\n  });\n}\n\nasync function main() {\n  var data = await getJSON();\n  console.log(data); // NOT undefined!\n}\n\nmain();\n</code></pre>\n\n<p>它内部所实现方式的和 Generator + Promise 的组合其实是一样的。</p>\n\n<h1 id=\"15gettersetter\">15. Getter/Setter 函数</h1>\n\n<p>ES6 已经开始实现了 <code>getter</code> 和 <code>setter</code> 函数，比如下面这个例子：</p>\n\n<pre><code>class Employee {\n    constructor(name) {\n        this._name = name;\n    }\n\n    get name() {\n      if(this._name) {\n        return 'Mr. ' + this._name.toUpperCase();  \n      } else {\n        return undefined;\n      }  \n    }\n\n    set name(newName) {\n      if (newName == this._name) {\n        console.log('I already have this name.');\n      } else if (newName) {\n        this._name = newName;\n      } else {\n        return false;\n      }\n    }\n}\n\nvar emp = new Employee(\"James Bond\");\n\n// uses the get method in the background\nif (emp.name) {\n  console.log(emp.name);  // Mr. JAMES BOND\n}\n\n// uses the setter in the background\nemp.name = \"Bond 007\";\nconsole.log(emp.name);  // Mr. BOND 007\n</code></pre>\n\n<p>最新版本的浏览器也在对象中实现了 <code>getter</code> 和 <code>setter</code>函数，我们可以使用它们来实现<strong>计算属性</strong>，在设置和获取一个属性之前加上监听器和处理。</p>\n\n<pre><code>var person = {\n  firstName: 'James',\n  lastName: 'Bond',\n  get fullName() {\n      console.log('Getting FullName');\n      return this.firstName + ' ' + this.lastName;\n  },\n  set fullName (name) {\n      console.log('Setting FullName');\n      var words = name.toString().split(' ');\n      this.firstName = words[0] || '';\n      this.lastName = words[1] || '';\n  }\n}\n\n\nperson.fullName; // James Bond\nperson.fullName = 'Bond 007';\nperson.fullName; // Bond 007\n</code></pre>\n\n<p>比如 Vue2 中就是通过<code>getter</code>和<code>setter</code>函数实现的数据监听。</p>",
                  "category": "Javascript基础",
                    "tags": "Javascript,进阶知识,ES6,面试总结",
                      "__v": 0,
                        "isShow": true,
                          "time": {
          "updateAt": "2017-03-28T07:14:53.478Z",
            "createAt": "2017-02-26T15:14:44.313Z"
        },
        "numbers": {
          "comment": 8,
            "like": 14,
              "view": 431
        }
      }
    };
  },

  componentWillReceiveProps(nextProps) {

    // 相等的时候，不更新
    if(nextProps.blogId == this.props.blogId) {
      return false;
    }

    // 与当前页切换博文详情时，发送请求，更新页面
    BlogAction.fetchBlogDetail(nextProps.blogId);  
  },

  componentDidMount() {
    setTimeout(() => {
      document.querySelectorAll('.atc-content pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    }, 1000);
    BlogStore.addChangeListener('BLOG_DETAIL', this.updateContent);
    
  },

  componentWillUnmount() {

    BlogStore.removeChangeListener('BLOG_DETAIL', this.updateContent)  

  },

  updateContent() {
    this.setState({
      blog: BlogStore.getBlogDetail()
    });

    setTimeout(() => {
      document.querySelectorAll('.atc-content pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    }, 200);

  },	

  render() {
    return (
      <div className="article-main">
        <ArticleContent 
          blogId={this.state.blog.blogId || -1}
          title={this.state.blog.title || '此文章不存在'}
          createAt={this.state.blog.time.createAt || '0000:00:00'}
          updateAt={this.state.blog.time.updateAt || '0000:00:00'}
          category={this.state.blog.category || ''}
          content={this.state.blog.content || ''}
          tags={this.state.blog.tags || ''}
        />
        {
          this.state.blog.blogId != -1 ? 
          <ArticleHot
            blogId={this.state.blog.blogId || -1}
            numbers={this.state.blog.numbers}
          />
          : ''
        }
        {
          this.state.blog.blogId != -1 ? 
          <ArticleComment
            blogId={this.state.blog.blogId || -1}
          />
          : ''
        }
      </div>
    )
  }

});

export default ArticlePanel;